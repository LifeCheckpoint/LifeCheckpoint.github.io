---
title: 01A. 数字系统与二进制编码基础与运算
authors: [Life_Checkpoint]
tags: [note]
sidebar_position: 1
---

## 1. 数字信号与数字系统基础

- **信号 (Signal)**: 用于表示和传递信息的物理量。
    - **模拟信号 (Analog Signal)**: 幅度和频率连续变化的波形。
    - **数字信号 (Digital Signal)**: 只有 `ON` (1) 和 `OFF` (0) 两种状态的离散波形。
- **比特 (Bit)**: 二进制数字 (binary digit) 的缩写，是信息的基本单位。
    - `1`: 代表高电平 (HIGH) 或真 (TRUE)。
    - `0`: 代表低电平 (LOW) 或假 (FALSE)。
- **逻辑电平 (Logic Levels)**: 在电路中，用一个电压范围来表示 `0` 和 `1`，例如 $0V \sim 0.8V$ 为低电平， $2V \sim 5V$ 为高电平。

## 2. 核心数制及其转换

数字系统中常用的数制包括十进制 (Decimal, base-10)、二进制 (Binary, base-2)、八进制 (Octal, base-8) 和十六进制 (Hexadecimal, base-16)。

### 2.1. 任意进制 (Radix-r) 转换为十进制

**核心方法：按权展开求和 (Positional Number System)**。
一个具有 $n$ 位整数和 $m$ 位小数的 $r$ 进制数，其值为：
$$ V = \sum_{i=-m}^{n-1} d_i \times r^i $$
其中 $d_i$ 是该数位上的数字， $r$ 是基数 (Radix)，小数点左侧第一位是 $i=0$，右侧第一位是 $i=-1$。

- **最高有效位 (Most-Significant Digit, MSD)**: 最左边的数字。
- **最低有效位 (Least-Significant Digit, LSD)**: 最右边的数字。

**【用例】**
将二进制数 $(101.01)_2$ 转换为十进制：
$$
(101.01)_2 = 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 + 0 \times 2^{-1} + 1 \times 2^{-2} \\
= 4 + 0 + 1 + 0 + 0.25 \\
= (5.25)_{10}
$$

### 2.2. 十进制转换为任意进制 (Radix-r)

**核心方法**：整数部分和小数部分分开处理。

1.  **整数部分：<u>除基取余法</u>**
    - 将十进制整数反复除以目标基数 $r$。
    - 每次的**余数**作为新数制的一位，直到商为 0。
    - **<u>注意：将余数从下往上（从最后一次的余数到第一次的余数）排列，即为转换结果（从 MSB 到 LSB）。</u>**

2.  **小数部分：<u>乘基取整法</u>**
    - 将十进制小数反复乘以目标基数 $r$。
    - 每次的**整数部分**作为新数制的一位，取剩下的小数部分继续。
    - **<u>注意：将整数从上往下（从第一次的整数到最后一次的整数）排列，即为转换结果（从 MSB 到 LSB）。</u>**

**【用例】**
将十进制数 $(35.375)_{10}$ 转换为二进制：

- **整数部分 (35)**:
    - $35 \div 2 = 17 \dots\dots 1$ (LSB)
    - $17 \div 2 = 8 \dots\dots 1$
    - $8 \div 2 = 4 \dots\dots 0$
    - $4 \div 2 = 2 \dots\dots 0$
    - $2 \div 2 = 1 \dots\dots 0$
    - $1 \div 2 = 0 \dots\dots 1$ (MSB)
    - 结果 (从下往上读): $(100011)_2$

- **小数部分 (0.375)**:
    - $0.375 \times 2 = 0.75 \to$ 整数部分为 `0` (MSB)
    - $0.75 \times 2 = 1.5 \to$ 整数部分为 `1`
    - $0.5 \times 2 = 1.0 \to$ 整数部分为 `1` (LSB)
    - 结果 (从上往下读): $(0.011)_2$

- **最终结果**: $(35.375)_{10} = (100011.011)_2$

### 2.3. 二、八、十六进制间的快速转换

**核心方法**：利用 $2^3=8$ 和 $2^4=16$ 的关系进行分组转换。

- **二进制 $\leftrightarrow$ 八进制**:
    - **<u>以小数点为界，整数部分向左、小数部分向右，每 3 位二进制数分为一组</u>**，不足 3 位的用 0 补齐。
    - 每组独立转换为一位八进制数。

- **二进制 $\leftrightarrow$ 十六进制**:
    - **<u>以小数点为界，整数部分向左、小数部分向右，每 4 位二进制数分为一组</u>**，不足 4 位的用 0 补齐。
    - 每组独立转换为一位十六进制数。

- **八进制 $\leftrightarrow$ 十六进制**:
    - 先转换为二进制作为中间步骤。

**【用例】**
将 $(10110.01)_2$ 转换为八进制和十六进制：
$$
\begin{array}{c|c|c}
\text{补零分组 (八进制)} & (\underline{010}\ \underline{110} . \underline{010})_2 & \text{结果} \\
\hline
\text{转换} & (2\ 6 . 2)_8 & (26.2)_8 \\
\end{array}
$$
$$
\begin{array}{c|c|c}
\text{补零分组 (十六进制)} & (\underline{0001}\ \underline{0110} . \underline{0100})_2 & \text{结果} \\
\hline
\text{转换} & (1\ 6 . 4)_{16} & (16.4)_{16} \\
\end{array}
$$

## 3. 二进制运算与补码

### 3.1. 二进制加减法

- **加法**: 与十进制加法类似，逢二进一。
- **减法**: 与十进制减法类似，需要向高位借位。但电路实现复杂。

### 3.2. 补码 (Complement)

**核心目的**：**<u>将减法运算转换为加法运算，从而简化计算机硬件设计</u>**。

| 进制 | 类型 | 中文名 | 定义 ($N$ 为数值, $n$ 为位数, $r$ 为基数) | 快速求法 |
| :--- | :--- | :--- | :--- | :--- |
| **二进制** | (r-1)'s | **反码 (1's Complement)** | $2^n - 1 - N$ | **各位取反** (0 变 1，1 变 0) |
| | r's | **补码 (2's Complement)** | $2^n - N$ | **反码加一** 或 **从右向左找到第一个 1，该 1 及其右边不变，左边各位取反** |
| 十进制 | (r-1)'s | 9's Complement | $10^n - 1 - N$ | 用 $n$ 个 9 减去原数 |
| | r's | 10's Complement | $10^n - N$ | 9's Complement 加一 |

**【重点】二的补码 (2's Complement) 求法**
对于二进制数 `10110000`:
1.  **方法一 (反码加一)**:
    - 反码: `01001111`
    - 加一: `01001111 + 1 = 01010000`
2.  **方法二 (保留首个 1)**:
    - 从右向左找到第一个 `1`: `1011**0000**`
    - 该 `1` 及其右边的位保持不变: `....**0000**` (错误，应为 `10000`)
    - 正确应为：从右向左，遇到的第一个 `1` 及其右边的所有位保持不变，该 `1` 左边的所有位取反。
    - `10110000` -> 从右向左第一个 1 在第 5 位。
    - `101` `10000` -> `10000` 不变，`101` 取反为 `010`。
    - 结果: `01010000`

### 3.3. 使用补码进行减法

**核心算法**: $M - N = M + (-N)_{\text{补}}$

- **前提**: $M$ 和 $N$ 必须有相同的位数，不足则在高位补 0。
- **步骤**:
    1.  求减数 $N$ 的补码（通常是 2's complement）。
    2.  被减数 $M$ 加上 $N$ 的补码。
    3.  根据结果判断：
        - **<u>如果产生最高位进位 (End Carry)，则舍弃该进位，结果为正</u>**。
        - **<u>如果没有最高位进位，则结果为负，其值为对当前结果再次求补码</u>**。

**【用例】**
使用 7 位二进制数和 2's complement 计算 $X-Y$ 和 $Y-X$，其中 $X = (1010100)_2$, $Y = (1000011)_2$。

- **计算 $X - Y$ ($M \ge N$)**:
    1.  $Y$ 的 2's complement:
        - $Y$ 的反码: `0111100`
        - $Y$ 的补码: `0111101`
    2.  相加:
        $$
        \begin{array}{rc}
        & 1010100 & (X) \\
        + & 0111101 & (Y\text{的补码}) \\
        \hline
        \mathbf{1} & 0010001 &
        \end{array}
        $$
    3.  结果：有最高位进位 `1`，舍弃。结果为正，即 $(0010001)_2$。

- **计算 $Y - X$ ($M < N$)**:
    1.  $X$ 的 2's complement:
        - $X$ 的反码: `0101011`
        - $X$ 的补码: `0101100`
    2.  相加:
        $$
        \begin{array}{rc}
        & 1000011 & (Y) \\
        + & 0101100 & (X\text{的补码}) \\
        \hline
        \mathbf{0} & 1101111 &
        \end{array}
        $$
    3.  结果：无最高位进位。结果为负，其大小需对 `1101111` 再次求 2's complement。
        - `1101111` 的反码: `0010000`
        - 加一: `0010001`
    4.  最终结果为 $-(0010001)_2$。

## 4. 带符号二进制数表示法

为了在二进制中表示正负数，通常将**最高有效位 (MSB) 作为符号位**：
- **`0`**: 正数
- **`1`**: 负数

**【重点】三种带符号数表示法的对比 (以 8 位为例)**

| 表示法 | 正数表示 (+X) | 负数表示 (-X) | 特点 |
| :--- | :--- | :--- | :--- |
| **原码 (Sign-Magnitude)** | 符号位为 0，其余位为数值的绝对值。 | 符号位为 1，其余位为数值的绝对值。 | - 直观，但加减法规则复杂。<br />- **有两个 0 的表示** (`+0` 和 `-0`)。 |
| **反码 (Signed-1's Complement)** | 与原码相同。 | 符号位为 1，其余位为数值绝对值的**反码**。 | - 加减法比原码简单。<br />- **仍有两个 0 的表示** (`+0` 和 `-0`)。 |
| **<u>补码 (Signed-2's Complement)</u>** | 与原码相同。 | 符号位为 1，其余位为数值绝对值的**补码**。 | - **加减法统一**，硬件实现最简单。<br />- **只有一个 0 的表示**。<br />- 表示范围比原码和反码多一个负数。 |

**【用例】** 用 8 位二进制表示 $\pm 105$
$(105)_{10} = (1101001)_2$

- **正数 $(+105)_{10}$**: 三种表示法都相同
  - `01101001`
- **负数 $(-105)_{10}$**:
  - **原码**: `11101001` (符号位变 1)
  - **反码**: `10010110` (数值位 `1101001` 取反)
  - **补码**: `10010111` (反码 `10010110` 加 1)

**为什么现代计算机普遍使用补码？**

| 特性 | 原码 | 反码 | **补码** |
| :--- | :--- | :--- | :--- |
| **加法运算** | 规则复杂 | 规则复杂 (需循环进位) | **规则统一，可直接相加** |
| **0 的表示** | `0000` 和 `1000` | `0000` 和 `1111` | **唯一 `0000`** |
| **N 位表示范围** | $[-(2^{N-1}-1), 2^{N-1}-1]$ | $[-(2^{N-1}-1), 2^{N-1}-1]$ | **$[-2^{N-1}, 2^{N-1}-1]$** |

## 5. 其他二进制编码

### 5.1. BCD 码 (Binary-Coded Decimal)

- **定义**: 用 4 位二进制数来表示一位十进制数 (0-9)。也称 **8421 码**。
- **特点**:
    - `0011 1001 0110` 代表十进制数 `396`。
    - 4 位二进制组合 `1010` 到 `1111` 是无效的 BCD 码。
- **BCD 加法**:
    1.  按二进制加法规则对位。
    2.  **<u>如果任意一组 4 位数的结果大于 9，或者产生了向高一组的进位，则该组需要修正</u>**。
    3.  **修正方法**: **<u>对该组加 6 (即 `0110` )</u>**。
        - **原因**: 二进制加法是逢 16 进位，而 BCD 码需要逢 10 进位，加 6 是为了跳过 6 个无效状态，从而实现正确的进位。

**【用例】** 计算 $184 + 576$ 的 BCD 码
$$
\begin{array}{rcccl}
& 0001 & 1000 & 0100 & (184) \\
+ & 0101 & 0111 & 0110 & (576) \\
\hline
& 0111 & \mathbf{10000} & \mathbf{1010} & \text{二进制和} \\
\text{修正} & & \uparrow & \uparrow & \\
& & \text{有进位} & >9 & \\
+ & & 0110 & 0110 & \text{加6修正} \\
\hline
& \mathbf{0111} & \mathbf{0110} & \mathbf{0000} & \text{最终结果} \\
& \downarrow & \downarrow & \downarrow & \\
& 7 & 6 & 0 & (760)
\end{array}
$$

### 5.2. 格雷码 (Gray Code)

- **特点**: **<u>相邻两个数值之间只有一位二进制数不同</u>**。
- **应用**: 减少数据转换过程中的瞬时错误、低功耗设计、模拟数据编码。

### 5.3. ASCII 码

- **全称**: American Standard Code for Information Interchange (美国信息交换标准代码)。
- **用途**: 用一个唯一的二进制数（通常是 7 位）表示数字、字母、标点符号和控制字符，共 128 个。

### 5.4. 奇偶校验码 (Error-Detecting Code)

- **目的**: 检测数据在传输或存储过程中是否发生错误。
- **方法**: 在原始数据上附加一位**校验位 (Parity Bit)**。
    - **偶校验 (Even Parity)**: 附加一位，使得整个编码中 `1` 的个数为偶数。
    - **奇校验 (Odd Parity)**: 附加一位，使得整个编码中 `1` 的个数为奇数。
- **局限性**: 只能检测出奇数个位的错误，无法检测出偶数个位的错误，也无法纠正错误。

## 6. 二进制逻辑入门

- **定义**: 处理只有两个值（`0`和`1`）的变量的逻辑体系。
- **基本逻辑运算**:

| 运算          | 符号                   | 描述             | 逻辑门 | 真值表 (A, B 为输入, Y 为输出)                                                    |
| :---------- | :------------------- | :------------- | :-- | :----------------------------------------------------------------------- |
| **与 (AND)** | $\cdot$ 或 省略         | 所有输入为 1，输出才为 1 | 与门  | `A=0, B=0, Y=0`<br />`A=0, B=1, Y=0`<br />`A=1, B=0, Y=0`<br />`A=1, B=1, Y=1` |
| **或 (OR)**  | $+$                  | 任一输入为 1，输出就为 1 | 或门  | `A=0, B=0, Y=0`<br />`A=0, B=1, Y=1`<br />`A=1, B=0, Y=1`<br />`A=1, B=1, Y=1` |
| **非 (NOT)** | $'$ 或 $\overline{A}$ | 输入与输出相反        | 非门  | `A=0, Y=1`<br />`A=1, Y=0`                                                 |