---
title: 01B. FPGA 入门：数字逻辑的硬件实现基础
authors: [Life_Checkpoint]
tags: [note]
sidebar_position: 1
---


## 1. 核心对比：CPU vs. FPGA

为了理解 FPGA 的特点，我们可以将其与 CPU 进行对比，两者在执行计算任务（例如 $a+b$）时的方式截然不同。

| 方面 | CPU (软件执行) | FPGA (硬件实现) |
| :--- | :--- | :--- |
| **实现方式** | 使用高级语言（如 C 语言）编写程序。 | 使用**硬件描述语言 (Hardware Description Language, HDL)**，如 Verilog，来描述电路。 |
| **核心过程** | **编译 (Compilation)** | **综合 (Synthesis)** |
| **产物** | 针对特定 CPU 架构的**机器码 (Machine Code)**。 | 描述具体硬件连接的**电路网表 (Netlist)**，最终生成配置文件。 |
| **执行本质** | **<u>指令的顺序执行</u>**：CPU 读取并执行一条条指令来完成计算。 | **<u>电路的并行工作</u>**：综合过程将 HDL 代码直接转化为物理的、并行的逻辑门和寄存器电路。 |

**结论**：CPU 是通用处理器，通过执行软件指令完成任务；FPGA 则是可编程的硬件，通过配置内部电路来直接构造一个专用的数字系统。

---

## 2. 什么是 FPGA？

- **定义**：**FPGA (Field-Programmable Gate Array)**，即**<u>现场可编程门阵列</u>**。它是一种数字逻辑设备，其内部的硬件结构可以被用户**编程**和**重编程**，以实现各种不同的数字功能。
- **核心思想**：FPGA 内部包含大量可配置的逻辑单元和可编程的布线资源。可以将其想象成无数的“乐高”积木（逻辑单元）和连接线（布线资源），用户可以通过编程来决定如何搭建这些积木，从而实现特定的功能。

---

## 3. 为什么在数字逻辑课程中使用 FPGA？

1.  **可编程性 (Programmability)**
    - **<u>设计灵活</u>**：可以快速地设计、实现和测试数字电路。
    - **<u>易于迭代</u>**：如果设计有误或需要更新，只需重新编程 FPGA 即可，无需更换硬件。
2.  **学习价值 (Educational Value)**
    - 提供了一种将理论知识（如逻辑门、时序逻辑）转化为实际、可运行硬件的**实践途径**。

---

## 4. 如何使用 FPGA？（FPGA 设计流程）

一个典型的 FPGA 设计流程包含以下三个核心要素：

1.  **硬件描述语言 (HDL)**
    - 用来描述数字电路的行为和结构。
    - 常见语言：**Verilog HDL**。
2.  **电子设计自动化工具 (EDA Tools)**
    - 用于**综合、实现、仿真和下载**的软件。
    - 示例：**Vivado**。
    - **综合 (Synthesis)** 是此流程中的关键步骤，它将 HDL 代码“翻译”成由逻辑门和寄存器组成的电路结构。
3.  **FPGA 开发板 (FPGA Board)**
    - 包含 FPGA 芯片和外围电路的物理硬件。
    - 示例：**ego1**。

**设计流程可以概括为：**
$$
\text{RTL代码 (Verilog)} \xrightarrow{\text{EDA工具 (综合与实现)}} \text{比特流文件} \xrightarrow{\text{下载}} \text{FPGA开发板}
$$

---

## 5. 深入理解：从逻辑门到可编程的核心——查阅表 (LUT)

FPGA 实现可编程性的核心部件不是物理的与门、或门，而是一种更通用的结构——**查阅表 (Look-Up Table, LUT)**。

- **概念**：LUT 本质上是一个小容量的**可编程存储器 (RAM)**。它的**地址输入**端连接逻辑函数的输入变量，而存储器中**预先存入的值**就是逻辑函数的**真值表**结果。

- **工作原理**：当输入变量变化时，相当于查询存储器的不同地址，LUT 会立即输出该地址上存储的对应结果。

- **用例：使用一个 2 输入 LUT 实现与门 $z = a \ \text{AND} \ b$**

    1.  **确定逻辑函数**：我们要实现的是与门，其输入为 $a$ 和 $b$，输出为 $z$。
    2.  **列出真值表**：

        | a | b | z (a AND b) |
        |:-:|:-:|:-----------:|
        | 0 | 0 |      **0**      |
        | 0 | 1 |      **0**      |
        | 1 | 0 |      **0**      |
        | 1 | 1 |      **1**      |

    3.  **配置 LUT**：
        - 我们使用一个 2 输入 LUT，它有 $2^2 = 4$ 个存储单元。
        - 输入 $a$ 和 $b$ 作为 LUT 的地址线（例如 $b$ 是高位，$a$ 是低位，地址为 $ba$）。
        - 将真值表的输出结果 **`[0, 0, 0, 1]`** 依次写入 LUT 的存储单元中。

        | 地址 (ba) | 存储内容 (输出 z) |
        |:---------:|:------------------:|
        |    00     |         0          |
        |    01     |         0          |
        |    10     |         0          |
        |    11     |         1          |

    4.  **工作过程**：
        - 当输入为 $a=1, b=0$ 时，地址为 `01`，LUT 查询该地址，输出存储的值 `0`。
        - 当输入为 $a=1, b=1$ 时，地址为 `11`，LUT 查询该地址，输出存储的值 `1`。

- **重点结论**：
    - **<u>通过改变 LUT 中存储的内容，同一个 LUT 硬件可以实现任何相同输入数量的逻辑函数</u>**（如 AND, OR, XOR 等），而无需改变物理电路。
    - **这正是 FPGA“可编程”特性的根本来源**。FPGA 内部就是由成千上万个这样的 LUT 和可编程的连接线组成的。